(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{374:function(v,_,e){"use strict";e.r(_);var o=e(26),t=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h3",{attrs:{id:"vue3-的升级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-的升级"}},[v._v("#")]),v._v(" Vue3 的升级")]),v._v(" "),e("p",[e("code",[v._v("Vue3")]),v._v("的升级可是说是外部看起来没有大的变化，内部却早已经焕然一新；除了"),e("code",[v._v("composition API")]),v._v("外剩下的更新可能都不太是能表现在"),e("code",[v._v("API")]),v._v("层面的。\n我们要从以下几个方面来具体谈谈。")]),v._v(" "),e("h2",{attrs:{id:"架构升级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#架构升级"}},[v._v("#")]),v._v(" 架构升级")]),v._v(" "),e("p",[v._v("首先要说的就是架构的升级，采用"),e("code",[v._v("monorepo")]),v._v("来管理项目，拆分了"),e("code",[v._v("reactivity")]),v._v("、"),e("code",[v._v("runtime")]),v._v("和"),e("code",[v._v("complier")]),v._v("三个模块出来（"),e("code",[v._v("ssr")]),v._v("相关和"),e("code",[v._v("sfc")]),v._v("相关的不在讨论范围内），\n各个模块职责更加分明，"),e("code",[v._v("API")]),v._v("设计、测试用例也更加独立，各个模块之间耦合度变低，依赖关系和方式也更加明确；\n再加上采用"),e("code",[v._v("typescript")]),v._v("完全重写，这就已经带来自身维护性的提升。")]),v._v(" "),e("ul",[e("li",[e("h4",{attrs:{id:"reactivity"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reactivity"}},[v._v("#")]),v._v(" "),e("code",[v._v("reactivity")])])])]),v._v(" "),e("p",[v._v("拆分出来的"),e("code",[v._v("reactivity")]),v._v("更加专注于实现响应式，从"),e("code",[v._v("Vue2")]),v._v("与组件"),e("code",[v._v("watcher")]),v._v("耦合的模式变成以"),e("code",[v._v("effect")]),v._v("函数为单元来收集依赖，更加通用独立；\n实现了收集函数中依赖响应式数据的能力，使得"),e("code",[v._v("reactivity")]),v._v("有完备的响应式能力且不依赖于其他包。")]),v._v(" "),e("ul",[e("li",[e("h4",{attrs:{id:"runtime"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runtime"}},[v._v("#")]),v._v(" "),e("code",[v._v("runtime")])])])]),v._v(" "),e("p",[v._v("架构升级为"),e("code",[v._v("runtime")]),v._v("带来的主要影响是隔离了"),e("code",[v._v("core")]),v._v("和"),e("code",[v._v("dom")]),v._v("，通过"),e("code",[v._v("custom renderer API")]),v._v("来交互，这样的处理方式让多平台的渲染器创建不必再"),e("code",[v._v("fork")]),v._v("源码来修改。")]),v._v(" "),e("ul",[e("li",[e("h4",{attrs:{id:"complier"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#complier"}},[v._v("#")]),v._v(" "),e("code",[v._v("complier")])])])]),v._v(" "),e("p",[v._v("编译器除了服务于"),e("code",[v._v("runtime")]),v._v("的优化，同时也将编译过程的一些特性处理函数化、插件化，提升了扩展能力。")]),v._v(" "),e("h2",{attrs:{id:"object-defineproperty到proxy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty到proxy"}},[v._v("#")]),v._v(" "),e("code",[v._v("Object.defineProperty")]),v._v("到"),e("code",[v._v("proxy")])]),v._v(" "),e("p",[v._v("首先从"),e("code",[v._v("API")]),v._v("本身来说"),e("code",[v._v("proxy")]),v._v("的浏览器厂商优化做得就比"),e("code",[v._v("Object.defineProperty")]),v._v("更加好，这已经包含了性能的提升；\n但是"),e("code",[v._v("API")]),v._v("变更带来的更加重要的提升是源于"),e("code",[v._v("proxy")]),v._v("是一个真正的对于原对象的代理，\n而不是像"),e("code",[v._v("Vue2")]),v._v("时代需要递归遍历"),e("code",[v._v("data")]),v._v("中的所有层级数据并且一一设置"),e("code",[v._v("setter/getter")]),v._v("；\n"),e("code",[v._v("proxy")]),v._v("的代理默认是一层浅代理，将递归代理深层次属性的过程放在了"),e("code",[v._v("getter")]),v._v("阶段，也就意味着我们初始化响应式数据的性能会提升。\n当然"),e("code",[v._v("proxy")]),v._v("也是有兼容性问题的——作为一个新的语法无法在浏览器端被"),e("code",[v._v("polyfill")]),v._v("，在"),e("code",[v._v("Vue3")]),v._v("的正式版中是会有底层降级的兼容版本。")]),v._v(" "),e("h2",{attrs:{id:"重写virtual-dom以及编译时优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重写virtual-dom以及编译时优化"}},[v._v("#")]),v._v(" 重写"),e("code",[v._v("virtual dom")]),v._v("以及编译时优化")]),v._v(" "),e("p",[v._v("新版本采用了"),e("code",[v._v("typescript")]),v._v("重写了"),e("code",[v._v("virtual dom")]),v._v("，在"),e("code",[v._v("diff")]),v._v("算法上也采用了新的策略；并且加入了很多的编译时优化像是"),e("code",[v._v("cacheHandlers")]),v._v("、"),e("code",[v._v("hoistStatic")]),v._v("等等，\n同时为每个"),e("code",[v._v("vnode")]),v._v("打上"),e("code",[v._v("patchFlag")]),v._v("已提供更好的运行时有效信息。"),e("br"),v._v("\n针对传统"),e("code",[v._v("virtual dom")]),v._v("的需要深度对比的性能瓶颈（单个组件内部），提出了"),e("code",[v._v("block")]),v._v("的概念，以最小静态块提取动态内容，达到点对点直接对比，避免了不必要的遍历；\n为什么"),e("code",[v._v("Vue3")]),v._v("要花这么大的代价来保留"),e("code",[v._v("virtual dom")]),v._v("而不像"),e("code",[v._v("angular lvy")]),v._v("那样直接将模板编译成"),e("code",[v._v("dom")]),v._v("操作的指令集呢？究其原因是"),e("code",[v._v("Vue")]),v._v("不想摈弃"),e("code",[v._v("virtual dom")]),v._v("带来的表现力，\n想要达到向下能兼容高级场景的手写"),e("code",[v._v("render")]),v._v("需求，向上也能通过模板优化获取一个较好的运行时性能。")]),v._v(" "),e("h2",{attrs:{id:"函数化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数化"}},[v._v("#")]),v._v(" 函数化")]),v._v(" "),e("p",[v._v("这里的函数化不是仅指"),e("code",[v._v("composition API")]),v._v("的函数化，也是在指内部的函数化。")]),v._v(" "),e("h4",{attrs:{id:"内部函数化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内部函数化"}},[v._v("#")]),v._v(" - 内部函数化")]),v._v(" "),e("p",[v._v("我们都知道"),e("code",[v._v("Vue2")]),v._v("是十分依赖"),e("code",[v._v("this")]),v._v("的，所有的"),e("code",[v._v("data")]),v._v("、"),e("code",[v._v("methods")]),v._v("、"),e("code",[v._v("computed")]),v._v("等等都需要一一在"),e("code",[v._v("this")]),v._v("上进行挂载；\n针对这点"),e("code",[v._v("Vue3")]),v._v("的组件创建不再通过"),e("code",[v._v("new")]),v._v("一个"),e("code",[v._v("Vue")]),v._v("的实例，而是通过对象字面量的方式；"),e("code",[v._v("render")]),v._v("函数执行不再依赖"),e("code",[v._v("this")]),v._v("，\n而是通过一个"),e("code",[v._v("proxy")]),v._v("来搞定，"),e("code",[v._v("proxy")]),v._v("本身就可以实现使用时再获取，同时也不需要预先进行所有属性方法的逐个"),e("code",[v._v("define")]),v._v("，是真正的"),e("code",[v._v("getter")]),v._v("访问原数据；\n这些优化都提升了组件启动的性能。")]),v._v(" "),e("h4",{attrs:{id:"api的函数化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#api的函数化"}},[v._v("#")]),v._v(" - "),e("code",[v._v("API")]),v._v("的函数化")]),v._v(" "),e("p",[v._v("更加函数化的"),e("code",[v._v("composition API")]),v._v("不仅在"),e("code",[v._v("typescript")]),v._v("支持上更加友好，同时提供了更加灵活的逻辑组合能力；\n摆脱了"),e("code",[v._v("options API")]),v._v("相关逻辑内容无法很好地聚合在一起需要在"),e("code",[v._v("data")]),v._v("、"),e("code",[v._v("methods")]),v._v("等等选项中来回切换的问题，\n同时"),e("code",[v._v("functional")]),v._v("的逻辑封装客观上更容易使用"),e("code",[v._v("import")]),v._v("来导入，在"),e("code",[v._v("tree shaking")]),v._v("和逻辑复用方面也是更加的灵活；\n所有的内部"),e("code",[v._v("API")]),v._v("都通过"),e("code",[v._v("vue")]),v._v("来导出也能更好地支持"),e("code",[v._v("tree shaking")]),v._v("；\n函数化的代码也更加容易压缩，函数作用域内的变量名都能被安全的智能压缩。\n这些优化提升使得"),e("code",[v._v("Vue")]),v._v("体积能够在"),e("code",[v._v("13.5kb")]),v._v("到"),e("code",[v._v("22.5kb")]),v._v("之间伸缩。")]),v._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),e("p",[e("code",[v._v("Vue3")]),v._v("从自身可维护性、性能和大型应用的逻辑复用问题出发，做了深度的优化处理；在经历了"),e("code",[v._v("class API")]),v._v("推翻到"),e("code",[v._v("function-based API")]),v._v("，\n同时还对"),e("code",[v._v("virtual dom")]),v._v("和编译器进行重写，尤大对细节的极致追求造就了现在的"),e("code",[v._v("Vue3")]),v._v("形态，让我们在接下来的内容中慢慢解开这背后的实现细节。")])])}),[],!1,null,null,null);_.default=t.exports}}]);